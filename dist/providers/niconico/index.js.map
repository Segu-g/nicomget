{"version":3,"sources":["../../../src/providers/niconico/NiconicoProvider.ts","../../../src/providers/niconico/WebSocketClient.ts","../../../src/providers/niconico/MessageStream.ts","../../../src/providers/niconico/ProtobufParser.ts","../../../src/providers/niconico/SegmentStream.ts","../../../src/providers/niconico/BackwardStream.ts"],"sourcesContent":["import { EventEmitter } from 'events';\nimport type { ICommentProvider } from '../../interfaces/ICommentProvider.js';\nimport type { BroadcastMetadata, Comment, ConnectionState, Gift, Emotion, Notification, OperatorComment } from '../../interfaces/types.js';\nimport type { NicoChat, NicoGift, NicoEmotion, NicoNotification, NicoOperatorComment } from './ProtobufParser.js';\nimport { WebSocketClient } from './WebSocketClient.js';\nimport { MessageStream } from './MessageStream.js';\nimport { SegmentStream } from './SegmentStream.js';\nimport { BackwardStream } from './BackwardStream.js';\n\n/** バックログで取得するイベント種別 */\nexport type BacklogEventType = 'chat' | 'gift' | 'emotion' | 'notification' | 'operatorComment';\n\nexport interface NiconicoProviderOptions {\n  liveId: string;\n  cookies?: string;\n  maxRetries?: number;\n  retryIntervalMs?: number;\n  /** 過去コメント（バックログ）を取得するか（デフォルト: true） */\n  fetchBacklog?: boolean;\n  /** バックログで取得するイベント種別（デフォルト: ['chat'] — チャットのみ） */\n  backlogEvents?: BacklogEventType[];\n}\n\n/**\n * ニコニコ生放送コメントプロバイダー。\n * ICommentProvider を実装し、放送ページからコメントを取得する。\n */\nexport class NiconicoProvider extends EventEmitter implements ICommentProvider {\n  private readonly liveId: string;\n  private readonly cookies?: string;\n  private readonly maxRetries: number;\n  private readonly retryIntervalMs: number;\n  private readonly fetchBacklog: boolean;\n  private readonly backlogEvents: Set<BacklogEventType>;\n  private wsClient: WebSocketClient | null = null;\n  private messageStream: MessageStream | null = null;\n  private segmentStreams: SegmentStream[] = [];\n  private fetchedSegments = new Set<string>();\n  private backwardStream: BackwardStream | null = null;\n  private seenChatNos = new Set<number>();\n  private state: ConnectionState = 'disconnected';\n  private intentionalDisconnect = false;\n  private reconnectCount = 0;\n  private reconnectTimer: ReturnType<typeof setTimeout> | null = null;\n\n  constructor(options: NiconicoProviderOptions) {\n    super();\n    this.liveId = options.liveId;\n    this.cookies = options.cookies;\n    this.maxRetries = options.maxRetries ?? 5;\n    this.retryIntervalMs = options.retryIntervalMs ?? 5000;\n    this.fetchBacklog = options.fetchBacklog ?? true;\n    this.backlogEvents = new Set(options.backlogEvents ?? ['chat']);\n  }\n\n  async connect(): Promise<void> {\n    this.intentionalDisconnect = false;\n    this.setState('connecting');\n\n    try {\n      // Step 1: 放送ページからWebSocket URLと放送者情報を取得\n      const { wsUrl, metadata } = await this.fetchWebSocketUrl();\n\n      await this.connectWebSocket(wsUrl);\n      this.reconnectCount = 0;\n      this.setState('connected');\n      this.emit('metadata', metadata);\n    } catch (error) {\n      this.setState('error');\n      throw error;\n    }\n  }\n\n  private async connectWebSocket(webSocketUrl: string): Promise<void> {\n    this.wsClient = new WebSocketClient(webSocketUrl);\n\n    this.wsClient.on('messageServer', (viewUri: string) => {\n      this.startMessageStream(viewUri);\n    });\n\n    this.wsClient.on('disconnect', (reason: string) => {\n      this.emit('error', new Error(`Disconnected: ${reason}`));\n      this.setState('disconnected');\n    });\n\n    this.wsClient.on('error', (error: Error) => {\n      this.emit('error', error);\n    });\n\n    this.wsClient.on('close', () => {\n      if (!this.intentionalDisconnect) {\n        this.scheduleReconnect();\n      } else {\n        this.setState('disconnected');\n      }\n    });\n\n    await this.wsClient.connect();\n  }\n\n  disconnect(): void {\n    this.intentionalDisconnect = true;\n    if (this.reconnectTimer) {\n      clearTimeout(this.reconnectTimer);\n      this.reconnectTimer = null;\n    }\n    this.wsClient?.disconnect();\n    this.messageStream?.stop();\n    for (const s of this.segmentStreams) s.stop();\n    this.segmentStreams = [];\n    this.fetchedSegments.clear();\n    this.backwardStream?.stop();\n    this.backwardStream = null;\n    this.seenChatNos.clear();\n    this.wsClient = null;\n    this.messageStream = null;\n    this.setState('disconnected');\n  }\n\n  private setState(state: ConnectionState): void {\n    if (this.state !== state) {\n      this.state = state;\n      this.emit('stateChange', state);\n    }\n  }\n\n  private scheduleReconnect(): void {\n    if (this.reconnectCount >= this.maxRetries) {\n      this.emit('error', new Error(`Reconnection failed after ${this.maxRetries} attempts`));\n      this.setState('disconnected');\n      return;\n    }\n\n    this.reconnectCount++;\n    this.setState('connecting');\n\n    this.reconnectTimer = setTimeout(async () => {\n      this.reconnectTimer = null;\n      try {\n        const { wsUrl, metadata } = await this.fetchWebSocketUrl();\n        await this.connectWebSocket(wsUrl);\n        this.reconnectCount = 0;\n        this.setState('connected');\n        this.emit('metadata', metadata);\n      } catch {\n        this.scheduleReconnect();\n      }\n    }, this.retryIntervalMs);\n  }\n\n  /** 放送ページのHTMLからWebSocket URLと放送者情報を取得する */\n  private async fetchWebSocketUrl(): Promise<{ wsUrl: string; metadata: BroadcastMetadata }> {\n    const url = `https://live.nicovideo.jp/watch/${this.liveId}`;\n    const headers: Record<string, string> = {\n      'User-Agent':\n        'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',\n      Accept:\n        'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',\n      'Accept-Language': 'ja,en-US;q=0.9,en;q=0.8',\n    };\n    if (this.cookies) headers['Cookie'] = this.cookies;\n\n    const response = await fetch(url, { headers, signal: AbortSignal.timeout(30_000) });\n    if (!response.ok) {\n      throw new Error(`Failed to fetch broadcast page: ${response.status}`);\n    }\n\n    const html = await response.text();\n    const match = html.match(/id=\"embedded-data\"\\s+data-props=\"([^\"]+)\"/);\n    if (!match) {\n      throw new Error('Could not find embedded data in the page');\n    }\n\n    const propsJson = match[1]\n      .replace(/&quot;/g, '\"')\n      .replace(/&amp;/g, '&')\n      .replace(/&lt;/g, '<')\n      .replace(/&gt;/g, '>');\n\n    const props = JSON.parse(propsJson);\n    const wsUrl = props.site?.relive?.webSocketUrl;\n    if (!wsUrl) {\n      throw new Error('WebSocket URL not found in broadcast data');\n    }\n\n    const supplier = props.program?.supplier;\n    const metadata: BroadcastMetadata = {\n      broadcasterName: supplier?.name ?? undefined,\n      broadcasterUserId: supplier?.userId != null ? String(supplier.userId) : undefined,\n    };\n\n    return { wsUrl, metadata };\n  }\n\n  private startMessageStream(viewUri: string): void {\n    this.replaceMessageStream(viewUri, 'now');\n  }\n\n  private replaceMessageStream(viewUri: string, at: string): void {\n    if (this.messageStream) {\n      this.messageStream.removeAllListeners();\n      this.messageStream.stop();\n    }\n    this.messageStream = new MessageStream(viewUri, this.cookies);\n\n    this.messageStream.on('segment', (segmentUri: string) => {\n      this.startSegmentStream(segmentUri);\n    });\n\n    this.messageStream.on('backward', (backwardUri: string) => {\n      if (this.fetchBacklog) {\n        this.startBackwardStream(backwardUri);\n      }\n    });\n\n    this.messageStream.on('next', (nextAt: string) => {\n      this.replaceMessageStream(viewUri, nextAt);\n    });\n\n    this.messageStream.on('error', (error: Error) => {\n      this.emit('error', error);\n    });\n\n    this.messageStream.on('end', () => {\n      // ストリームが nextAt なしで終了した場合、現在時刻で再接続\n      this.replaceMessageStream(viewUri, 'now');\n    });\n\n    this.messageStream.start(at).catch((err) => this.emit('error', err));\n  }\n\n  private startSegmentStream(segmentUri: string): void {\n    if (this.fetchedSegments.has(segmentUri)) return;\n    this.fetchedSegments.add(segmentUri);\n\n    const segment = new SegmentStream(segmentUri, this.cookies);\n\n    segment.on('chat', (chat: NicoChat) => {\n      if (this.isDuplicateChat(chat)) return;\n      this.emit('comment', this.mapChat(chat));\n    });\n\n    segment.on('gift', (nicoGift: NicoGift) => {\n      this.emit('gift', this.mapGift(nicoGift));\n    });\n\n    segment.on('emotion', (nicoEmotion: NicoEmotion) => {\n      this.emit('emotion', this.mapEmotion(nicoEmotion));\n    });\n\n    segment.on('notification', (nicoNotif: NicoNotification) => {\n      this.emit('notification', this.mapNotification(nicoNotif));\n    });\n\n    segment.on('operatorComment', (nicoOp: NicoOperatorComment) => {\n      this.emit('operatorComment', this.mapOperatorComment(nicoOp));\n    });\n\n    segment.on('error', (error: Error) => {\n      this.emit('error', error);\n    });\n\n    segment.on('end', () => {\n      const idx = this.segmentStreams.indexOf(segment);\n      if (idx >= 0) this.segmentStreams.splice(idx, 1);\n    });\n\n    this.segmentStreams.push(segment);\n    segment.start().catch((err) => this.emit('error', err));\n  }\n\n  private startBackwardStream(backwardUri: string): void {\n    // 既に backward stream が動作中の場合はスキップ\n    if (this.backwardStream) return;\n\n    const backward = new BackwardStream(backwardUri, this.cookies);\n    this.backwardStream = backward;\n\n    if (this.backlogEvents.has('chat')) {\n      backward.on('chat', (chat: NicoChat) => {\n        if (this.isDuplicateChat(chat)) return;\n        this.emit('comment', this.mapChat(chat, true));\n      });\n    }\n\n    if (this.backlogEvents.has('gift')) {\n      backward.on('gift', (nicoGift: NicoGift) => {\n        this.emit('gift', this.mapGift(nicoGift, true));\n      });\n    }\n\n    if (this.backlogEvents.has('emotion')) {\n      backward.on('emotion', (nicoEmotion: NicoEmotion) => {\n        this.emit('emotion', this.mapEmotion(nicoEmotion, true));\n      });\n    }\n\n    if (this.backlogEvents.has('notification')) {\n      backward.on('notification', (nicoNotif: NicoNotification) => {\n        this.emit('notification', this.mapNotification(nicoNotif, true));\n      });\n    }\n\n    if (this.backlogEvents.has('operatorComment')) {\n      backward.on('operatorComment', (nicoOp: NicoOperatorComment) => {\n        this.emit('operatorComment', this.mapOperatorComment(nicoOp, true));\n      });\n    }\n\n    backward.on('error', (error: Error) => {\n      this.emit('error', error);\n    });\n\n    backward.on('end', () => {\n      if (this.backwardStream === backward) {\n        this.backwardStream = null;\n      }\n    });\n\n    backward.start().catch((err) => this.emit('error', err));\n  }\n\n  /** chat.no ベースの重複排除（no > 0 のみ対象） */\n  private isDuplicateChat(chat: NicoChat): boolean {\n    if (chat.no <= 0) return false;\n    if (this.seenChatNos.has(chat.no)) return true;\n    this.seenChatNos.add(chat.no);\n    return false;\n  }\n\n  private mapChat(chat: NicoChat, isHistory?: boolean): Comment {\n    const rawUserId = chat.rawUserId != null ? Number(chat.rawUserId) : undefined;\n    const comment: Comment = {\n      id: String(chat.no),\n      content: chat.content,\n      userId: chat.hashedUserId || (rawUserId ? String(rawUserId) : undefined),\n      userName: chat.name?.startsWith('a:') ? undefined : chat.name ?? undefined,\n      userIcon: rawUserId ? `https://secure-dcdn.cdn.nimg.jp/nicoaccount/usericon/${Math.floor(rawUserId / 10000)}/${rawUserId}.jpg` : undefined,\n      timestamp: new Date(),\n      platform: 'niconico',\n      raw: chat,\n    };\n    if (isHistory) comment.isHistory = true;\n    return comment;\n  }\n\n  private mapGift(nicoGift: NicoGift, isHistory?: boolean): Gift {\n    const gift: Gift = {\n      itemId: nicoGift.itemId,\n      itemName: nicoGift.itemName,\n      userId: nicoGift.advertiserUserId != null ? String(Number(nicoGift.advertiserUserId)) : undefined,\n      userName: nicoGift.advertiserName,\n      point: Number(nicoGift.point),\n      message: nicoGift.message,\n      timestamp: new Date(),\n      platform: 'niconico',\n      raw: nicoGift,\n    };\n    if (isHistory) gift.isHistory = true;\n    return gift;\n  }\n\n  private mapEmotion(nicoEmotion: NicoEmotion, isHistory?: boolean): Emotion {\n    const emotion: Emotion = {\n      id: nicoEmotion.content,\n      timestamp: new Date(),\n      platform: 'niconico',\n      raw: nicoEmotion,\n    };\n    if (isHistory) emotion.isHistory = true;\n    return emotion;\n  }\n\n  private mapNotification(nicoNotif: NicoNotification, isHistory?: boolean): Notification {\n    const notification: Notification = {\n      type: nicoNotif.type,\n      message: nicoNotif.message,\n      timestamp: new Date(),\n      platform: 'niconico',\n      raw: nicoNotif,\n    };\n    if (isHistory) notification.isHistory = true;\n    return notification;\n  }\n\n  private mapOperatorComment(nicoOp: NicoOperatorComment, isHistory?: boolean): OperatorComment {\n    const operatorComment: OperatorComment = {\n      content: nicoOp.content,\n      name: nicoOp.name ?? undefined,\n      link: nicoOp.link ?? undefined,\n      timestamp: new Date(),\n      platform: 'niconico',\n      raw: nicoOp,\n    };\n    if (isHistory) operatorComment.isHistory = true;\n    return operatorComment;\n  }\n}\n","import { EventEmitter } from 'events';\nimport WebSocket from 'ws';\n\nexport interface WebSocketClientEvents {\n  messageServer: (viewUri: string) => void;\n  disconnect: (reason: string) => void;\n  error: (error: Error) => void;\n  open: () => void;\n  close: () => void;\n}\n\n/**\n * ニコニコ生放送の視聴WebSocket管理クラス。\n * startWatching送信、ping/pong応答、keepSeat定期送信を行う。\n */\nexport class WebSocketClient extends EventEmitter {\n  private ws: WebSocket | null = null;\n  private keepSeatInterval: ReturnType<typeof setInterval> | null = null;\n\n  constructor(private readonly webSocketUrl: string) {\n    super();\n  }\n\n  connect(): Promise<void> {\n    return new Promise((resolve, reject) => {\n      this.ws = new WebSocket(this.webSocketUrl);\n\n      this.ws.on('open', () => {\n        this.sendStartWatching();\n        this.emit('open');\n        resolve();\n      });\n\n      this.ws.on('message', (data) => {\n        try {\n          const message = JSON.parse(data.toString());\n          this.handleMessage(message);\n        } catch {\n          // ignore parse errors\n        }\n      });\n\n      this.ws.on('error', (error) => {\n        this.emit('error', error);\n        reject(error);\n      });\n\n      this.ws.on('close', () => {\n        this.stopKeepSeat();\n        this.emit('close');\n      });\n    });\n  }\n\n  disconnect(): void {\n    this.stopKeepSeat();\n    if (this.ws) {\n      this.ws.close();\n      this.ws = null;\n    }\n  }\n\n  private sendStartWatching(): void {\n    this.ws?.send(\n      JSON.stringify({\n        type: 'startWatching',\n        data: {\n          stream: {\n            quality: 'abr',\n            protocol: 'hls',\n            latency: 'low',\n            chasePlay: false,\n          },\n          room: {\n            protocol: 'webSocket',\n            commentable: false,\n          },\n          reconnect: false,\n        },\n      }),\n    );\n  }\n\n  private handleMessage(message: { type: string; data?: any }): void {\n    switch (message.type) {\n      case 'messageServer':\n        if (message.data?.viewUri) {\n          this.emit('messageServer', message.data.viewUri);\n        }\n        break;\n      case 'seat':\n        this.startKeepSeat(message.data?.keepIntervalSec ?? 30);\n        break;\n      case 'ping':\n        this.ws?.send(JSON.stringify({ type: 'pong' }));\n        break;\n      case 'disconnect':\n        this.emit('disconnect', message.data?.reason ?? 'unknown');\n        break;\n      case 'error':\n        this.emit('error', new Error(message.data?.message ?? 'WebSocket error'));\n        break;\n    }\n  }\n\n  private startKeepSeat(intervalSec: number): void {\n    this.stopKeepSeat();\n    const clamped = Math.max(10, Math.min(300, Number(intervalSec) || 30));\n    this.keepSeatInterval = setInterval(() => {\n      this.ws?.send(JSON.stringify({ type: 'keepSeat' }));\n    }, clamped * 1000);\n  }\n\n  private stopKeepSeat(): void {\n    if (this.keepSeatInterval) {\n      clearInterval(this.keepSeatInterval);\n      this.keepSeatInterval = null;\n    }\n  }\n}\n","import { EventEmitter } from 'events';\nimport {\n  extractMessages,\n  parseChunkedEntry,\n} from './ProtobufParser.js';\n\n/** バッファサイズ上限 (16 MB) */\nconst MAX_BUFFER_SIZE = 16 * 1024 * 1024;\n\n/** HTTP接続タイムアウト (30秒) */\nconst CONNECT_TIMEOUT_MS = 30_000;\n\n/** ストリーミング無通信タイムアウト (60秒) */\nconst INACTIVITY_TIMEOUT_MS = 60_000;\n\n/**\n * メッセージサーバーHTTPストリーミング。\n * viewUri に接続し ChunkedEntry を解析、segmentUri と nextAt を通知する。\n */\nexport class MessageStream extends EventEmitter {\n  private buffer = new Uint8Array(0);\n  private controller: AbortController | null = null;\n\n  constructor(\n    private readonly viewUri: string,\n    private readonly cookies?: string,\n  ) {\n    super();\n  }\n\n  /** ストリーミング開始（at パラメータ指定） */\n  async start(at: string = 'now'): Promise<void> {\n    const separator = this.viewUri.includes('?') ? '&' : '?';\n    const uri = `${this.viewUri}${separator}at=${at}`;\n    this.controller = new AbortController();\n\n    // 接続フェーズのみのタイムアウト（ヘッダ受信後にクリア）\n    const connectTimer = setTimeout(() => {\n      this.controller?.abort();\n    }, CONNECT_TIMEOUT_MS);\n\n    try {\n      const headers: Record<string, string> = {\n        'User-Agent':\n          'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',\n        Priority: 'u=1, i',\n      };\n      if (this.cookies) headers['Cookie'] = this.cookies;\n\n      const response = await fetch(uri, {\n        headers,\n        signal: this.controller.signal,\n      });\n\n      clearTimeout(connectTimer);\n\n      if (!response.ok || !response.body) {\n        throw new Error(`Message server returned ${response.status}`);\n      }\n\n      const reader = response.body.getReader();\n      await this.readStream(reader);\n    } catch (error) {\n      clearTimeout(connectTimer);\n      if ((error as Error).name !== 'AbortError') {\n        this.emit('error', error);\n      }\n    }\n  }\n\n  stop(): void {\n    this.controller?.abort();\n    this.controller = null;\n    this.buffer = new Uint8Array(0);\n  }\n\n  private async readStream(\n    reader: ReadableStreamDefaultReader<Uint8Array>,\n  ): Promise<void> {\n    let inactivityTimer: ReturnType<typeof setTimeout> | null = null;\n\n    const resetInactivityTimer = () => {\n      if (inactivityTimer) clearTimeout(inactivityTimer);\n      inactivityTimer = setTimeout(() => {\n        this.stop();\n        this.emit('error', new Error('Stream inactivity timeout'));\n      }, INACTIVITY_TIMEOUT_MS);\n    };\n\n    try {\n      resetInactivityTimer();\n      while (true) {\n        const { done, value } = await reader.read();\n        if (done) break;\n        resetInactivityTimer();\n        this.handleData(value);\n      }\n      this.emit('end');\n    } catch (error) {\n      if ((error as Error).name !== 'AbortError') {\n        this.emit('error', error);\n      }\n    } finally {\n      if (inactivityTimer) clearTimeout(inactivityTimer);\n    }\n  }\n\n  /** @internal テスト用に公開 */\n  handleData(chunk: Uint8Array): void {\n    const combined = new Uint8Array(this.buffer.length + chunk.length);\n    combined.set(this.buffer, 0);\n    combined.set(chunk, this.buffer.length);\n\n    const { messages, remaining } = extractMessages(combined);\n    this.buffer = new Uint8Array(remaining);\n\n    if (this.buffer.length > MAX_BUFFER_SIZE) {\n      this.buffer = new Uint8Array(0);\n      this.emit('error', new Error(`Buffer size exceeded limit (${MAX_BUFFER_SIZE} bytes)`));\n      this.stop();\n      return;\n    }\n\n    let nextAt: string | undefined;\n\n    for (const msg of messages) {\n      try {\n        const entry = parseChunkedEntry(msg);\n        if (entry.segmentUri) {\n          this.emit('segment', entry.segmentUri);\n        }\n        if (entry.backward?.segmentUri) {\n          this.emit('backward', entry.backward.segmentUri);\n        }\n        if (entry.nextAt) {\n          nextAt = entry.nextAt;\n        }\n      } catch {\n        // malformed protobuf — skip\n      }\n    }\n\n    // nextAt は全 segment を処理した後に発火\n    // (next ハンドラが removeAllListeners() を呼ぶため)\n    if (nextAt) {\n      this.emit('next', nextAt);\n    }\n  }\n}\n","import protobuf from 'protobufjs/minimal.js';\nconst { Reader } = protobuf;\n\nimport proto from '@n-air-app/nicolive-comment-protobuf';\nconst { ChunkedEntry, ChunkedMessage, PackedSegment } =\n  proto.dwango.nicolive.chat.service.edge;\nconst { SimpleNotificationV2 } = proto.dwango.nicolive.chat.data.atoms;\nconst NotificationType = SimpleNotificationV2.NotificationType;\n\n/** メッセージサイズ上限 (16 MB) — これを超えるメッセージは破棄する */\nconst MAX_MESSAGE_SIZE = 16 * 1024 * 1024;\n\n/** ニコニコ固有のChat — ライブラリの Chat クラスそのもの */\nexport type NicoChat = proto.dwango.nicolive.chat.data.Chat;\n\n/** ニコニコ固有のGift — ライブラリの Gift クラスそのもの */\nexport type NicoGift = proto.dwango.nicolive.chat.data.Gift;\n\n/** ニコニコ固有の放送者コメント — ライブラリの OperatorComment クラスそのもの */\nexport type NicoOperatorComment = proto.dwango.nicolive.chat.data.OperatorComment;\n\n/** ニコニコ固有のエモーション (SimpleNotificationV2 type=EMOTION) */\nexport interface NicoEmotion {\n  content: string;\n}\n\n/** SimpleNotificationV2 の通知タイプ (EMOTION 以外) */\nexport type NicoNotificationType =\n  | 'unknown'\n  | 'ichiba'\n  | 'cruise'\n  | 'program_extended'\n  | 'ranking_in'\n  | 'visited'\n  | 'supporter_registered'\n  | 'user_level_up'\n  | 'user_follow';\n\n/** ニコニコ固有の通知 (SimpleNotificationV2 type!=EMOTION) */\nexport interface NicoNotification {\n  type: NicoNotificationType;\n  message: string;\n}\n\n/** BackwardSegmentの解析結果 */\nexport interface BackwardSegmentResult {\n  segmentUri?: string;\n}\n\n/** ChunkedEntryの解析結果 */\nexport interface ChunkedEntryResult {\n  segmentUri?: string;\n  nextAt?: string;\n  backward?: BackwardSegmentResult;\n}\n\n/** PackedSegmentの解析結果 */\nexport interface PackedSegmentResult {\n  messages: ChunkedMessageResult[];\n  nextUri?: string;\n}\n\n/** ChunkedMessageの解析結果 */\nexport interface ChunkedMessageResult {\n  chats: NicoChat[];\n  gifts: NicoGift[];\n  emotions: NicoEmotion[];\n  notifications: NicoNotification[];\n  operatorComment?: NicoOperatorComment;\n  signal?: 'flushed';\n}\n\n/** NotificationType enum → NicoNotificationType 文字列マッピング（EMOTION は除外） */\nconst NOTIFICATION_TYPE_MAP: Record<number, NicoNotificationType> =\n  Object.fromEntries(\n    Object.entries(NotificationType)\n      .filter(([, v]) => typeof v === 'number' && v !== NotificationType.EMOTION)\n      .map(([k, v]) => [v, k.toLowerCase() as NicoNotificationType]),\n  );\n\n/**\n * Length-Delimitedバッファから1メッセージを読み取る。\n * データ不足の場合はnullを返す。\n */\nexport function readLengthDelimitedMessage(\n  buffer: Uint8Array,\n): { message: Uint8Array; bytesRead: number } | null {\n  if (buffer.length === 0) return null;\n\n  try {\n    const reader = new Reader(buffer);\n    const messageLength = reader.uint32();\n    const headerSize = reader.pos;\n\n    if (messageLength > MAX_MESSAGE_SIZE) {\n      throw new Error(`Message size ${messageLength} exceeds limit ${MAX_MESSAGE_SIZE}`);\n    }\n\n    if (buffer.length < headerSize + messageLength) return null;\n\n    const message = buffer.slice(headerSize, headerSize + messageLength);\n    return { message, bytesRead: headerSize + messageLength };\n  } catch {\n    return null;\n  }\n}\n\n/**\n * バッファからすべてのLength-Delimitedメッセージを抽出する。\n * 残りのバッファも返す。\n */\nexport function extractMessages(\n  buffer: Uint8Array,\n): { messages: Uint8Array[]; remaining: Uint8Array } {\n  const messages: Uint8Array[] = [];\n  let offset = 0;\n\n  while (offset < buffer.length) {\n    const result = readLengthDelimitedMessage(buffer.slice(offset));\n    if (!result) break;\n    messages.push(result.message);\n    offset += result.bytesRead;\n  }\n\n  return { messages, remaining: buffer.slice(offset) };\n}\n\n/**\n * ChunkedEntryをパースする。\n * メッセージサーバーから返るデータ。\n */\nexport function parseChunkedEntry(data: Uint8Array): ChunkedEntryResult {\n  const entry = ChunkedEntry.decode(data);\n  const result: ChunkedEntryResult = {};\n\n  const seg = entry.segment ?? entry.previous;\n  if (seg?.uri) result.segmentUri = seg.uri;\n\n  if (entry.backward?.segment?.uri) {\n    result.backward = { segmentUri: entry.backward.segment.uri };\n  }\n\n  if (entry.next?.at != null) {\n    result.nextAt = String(Number(entry.next.at));\n  }\n\n  return result;\n}\n\n/**\n * ChunkedMessageをパースする。\n * セグメントサーバーから返るデータ。\n */\nexport function parseChunkedMessage(data: Uint8Array): ChunkedMessageResult {\n  return convertChunkedMessage(ChunkedMessage.decode(data));\n}\n\n/** デコード済み ChunkedMessage を ChunkedMessageResult に変換する */\nfunction convertChunkedMessage(\n  msg: proto.dwango.nicolive.chat.service.edge.IChunkedMessage,\n): ChunkedMessageResult {\n  const result: ChunkedMessageResult = {\n    chats: [],\n    gifts: [],\n    emotions: [],\n    notifications: [],\n  };\n  const payload = (msg as { payload?: string }).payload;\n\n  if (payload === 'message' && msg.message) {\n    processNicoliveMessage(msg.message, result);\n  } else if (payload === 'state' && msg.state) {\n    const op = msg.state.marquee?.display?.operatorComment;\n    if (op) result.operatorComment = op as NicoOperatorComment;\n  } else if (\n    payload === 'signal' &&\n    msg.signal === ChunkedMessage.Signal.Flushed\n  ) {\n    result.signal = 'flushed';\n  }\n\n  return result;\n}\n\n/** NicoliveMessage から各データを抽出して result に格納する */\nfunction processNicoliveMessage(\n  nicoliveMsg: proto.dwango.nicolive.chat.data.INicoliveMessage,\n  result: ChunkedMessageResult,\n): void {\n  const data = (nicoliveMsg as { data?: string }).data;\n\n  if (data === 'chat' && nicoliveMsg.chat) {\n    result.chats.push(nicoliveMsg.chat as NicoChat);\n  } else if (data === 'overflowedChat' && nicoliveMsg.overflowedChat) {\n    result.chats.push(nicoliveMsg.overflowedChat as NicoChat);\n  } else if (data === 'simpleNotification' && nicoliveMsg.simpleNotification) {\n    if (nicoliveMsg.simpleNotification.emotion) {\n      result.emotions.push({ content: nicoliveMsg.simpleNotification.emotion });\n    }\n  } else if (data === 'gift' && nicoliveMsg.gift) {\n    result.gifts.push(nicoliveMsg.gift as NicoGift);\n  } else if (\n    data === 'simpleNotificationV2' &&\n    nicoliveMsg.simpleNotificationV2\n  ) {\n    const notif = nicoliveMsg.simpleNotificationV2;\n    const type = notif.type ?? 0;\n    if (type === NotificationType.EMOTION) {\n      result.emotions.push({ content: notif.message ?? '' });\n    } else {\n      const typeName = NOTIFICATION_TYPE_MAP[type] ?? 'unknown';\n      result.notifications.push({ type: typeName, message: notif.message ?? '' });\n    }\n  }\n}\n\n/**\n * PackedSegmentをパースする。\n * BackwardSegment の segment URI から取得される RAW protobuf データ。\n */\nexport function parsePackedSegment(data: Uint8Array): PackedSegmentResult {\n  const packed = PackedSegment.decode(data);\n  const result: PackedSegmentResult = { messages: [] };\n\n  if (packed.messages) {\n    for (const msg of packed.messages) {\n      result.messages.push(convertChunkedMessage(msg));\n    }\n  }\n\n  if (packed.next?.uri) {\n    result.nextUri = packed.next.uri;\n  }\n\n  return result;\n}\n","import { EventEmitter } from 'events';\nimport {\n  extractMessages,\n  parseChunkedMessage,\n} from './ProtobufParser.js';\n\n/** バッファサイズ上限 (16 MB) */\nconst MAX_BUFFER_SIZE = 16 * 1024 * 1024;\n\n/** HTTP接続タイムアウト (30秒) */\nconst CONNECT_TIMEOUT_MS = 30_000;\n\n/** ストリーミング無通信タイムアウト (60秒) */\nconst INACTIVITY_TIMEOUT_MS = 60_000;\n\n/**\n * セグメントサーバーHTTPストリーミング。\n * セグメントURIに接続し ChunkedMessage を解析、各種メッセージを通知する。\n */\nexport class SegmentStream extends EventEmitter {\n  private buffer = new Uint8Array(0);\n  private controller: AbortController | null = null;\n\n  constructor(\n    private readonly segmentUri: string,\n    private readonly cookies?: string,\n  ) {\n    super();\n  }\n\n  async start(): Promise<void> {\n    this.controller = new AbortController();\n\n    // 接続フェーズのみのタイムアウト（ヘッダ受信後にクリア）\n    const connectTimer = setTimeout(() => {\n      this.controller?.abort();\n    }, CONNECT_TIMEOUT_MS);\n\n    try {\n      const headers: Record<string, string> = {\n        'User-Agent':\n          'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',\n      };\n      if (this.cookies) headers['Cookie'] = this.cookies;\n\n      const response = await fetch(this.segmentUri, {\n        headers,\n        signal: this.controller.signal,\n      });\n\n      clearTimeout(connectTimer);\n\n      if (!response.ok || !response.body) {\n        throw new Error(`Segment server returned ${response.status}`);\n      }\n\n      const reader = response.body.getReader();\n      await this.readStream(reader);\n    } catch (error) {\n      clearTimeout(connectTimer);\n      if ((error as Error).name !== 'AbortError') {\n        this.emit('error', error);\n      }\n    }\n  }\n\n  stop(): void {\n    this.controller?.abort();\n    this.controller = null;\n    this.buffer = new Uint8Array(0);\n  }\n\n  private async readStream(\n    reader: ReadableStreamDefaultReader<Uint8Array>,\n  ): Promise<void> {\n    let inactivityTimer: ReturnType<typeof setTimeout> | null = null;\n\n    const resetInactivityTimer = () => {\n      if (inactivityTimer) clearTimeout(inactivityTimer);\n      inactivityTimer = setTimeout(() => {\n        this.stop();\n        this.emit('error', new Error('Stream inactivity timeout'));\n      }, INACTIVITY_TIMEOUT_MS);\n    };\n\n    try {\n      resetInactivityTimer();\n      while (true) {\n        const { done, value } = await reader.read();\n        if (done) break;\n        resetInactivityTimer();\n        this.handleData(value);\n      }\n      this.emit('end');\n    } catch (error) {\n      if ((error as Error).name !== 'AbortError') {\n        this.emit('error', error);\n      }\n    } finally {\n      if (inactivityTimer) clearTimeout(inactivityTimer);\n    }\n  }\n\n  /** @internal テスト用に公開 */\n  handleData(chunk: Uint8Array): void {\n    const combined = new Uint8Array(this.buffer.length + chunk.length);\n    combined.set(this.buffer, 0);\n    combined.set(chunk, this.buffer.length);\n\n    const { messages, remaining } = extractMessages(combined);\n    this.buffer = new Uint8Array(remaining);\n\n    if (this.buffer.length > MAX_BUFFER_SIZE) {\n      this.buffer = new Uint8Array(0);\n      this.emit('error', new Error(`Buffer size exceeded limit (${MAX_BUFFER_SIZE} bytes)`));\n      this.stop();\n      return;\n    }\n\n    for (const msg of messages) {\n      try {\n        const result = parseChunkedMessage(msg);\n        for (const chat of result.chats) {\n          this.emit('chat', chat);\n        }\n        for (const gift of result.gifts) {\n          this.emit('gift', gift);\n        }\n        for (const emotion of result.emotions) {\n          this.emit('emotion', emotion);\n        }\n        for (const notification of result.notifications) {\n          this.emit('notification', notification);\n        }\n        if (result.operatorComment) {\n          this.emit('operatorComment', result.operatorComment);\n        }\n      } catch {\n        // malformed protobuf — skip\n      }\n    }\n  }\n}\n","import { EventEmitter } from 'events';\nimport {\n  parsePackedSegment,\n  type ChunkedMessageResult,\n} from './ProtobufParser.js';\n\n/** チェーン追跡の最大深度 */\nconst MAX_CHAIN_DEPTH = 50;\n\n/** リクエスト間の待機時間 (ms) */\nconst FETCH_DELAY_MS = 100;\n\n/** レスポンスサイズ上限 (16 MB) */\nconst MAX_RESPONSE_SIZE = 16 * 1024 * 1024;\n\n/** HTTP接続タイムアウト (30秒) */\nconst CONNECT_TIMEOUT_MS = 30_000;\n\n/**\n * 過去コメント (BackwardSegment) 取得ストリーム。\n * PackedSegment URI チェーンを全て取得し、時系列順（古→新）にイベントを発火する。\n *\n * チェーンは新→旧の順で返されるため、全セグメントをバッファリングした後\n * 逆順に emit することで時系列順を保証する。\n */\nexport class BackwardStream extends EventEmitter {\n  private stopped = false;\n\n  constructor(\n    private readonly initialUri: string,\n    private readonly cookies?: string,\n  ) {\n    super();\n  }\n\n  async start(): Promise<void> {\n    // Phase 1: 全セグメントを取得（新→旧の順で蓄積される）\n    const segments: ChunkedMessageResult[][] = [];\n\n    let uri: string | undefined = this.initialUri;\n    let depth = 0;\n\n    while (uri && !this.stopped && depth < MAX_CHAIN_DEPTH) {\n      try {\n        const data = await this.fetchSegment(uri);\n        const packed = parsePackedSegment(data);\n        segments.push(packed.messages);\n\n        uri = packed.nextUri;\n        depth++;\n\n        if (uri && !this.stopped) {\n          await delay(FETCH_DELAY_MS);\n        }\n      } catch (error) {\n        if (!this.stopped) {\n          this.emit('error', error);\n        }\n        break;\n      }\n    }\n\n    if (this.stopped) return;\n\n    // Phase 2: 逆順に emit（古→新の時系列順）\n    for (let i = segments.length - 1; i >= 0; i--) {\n      for (const msg of segments[i]) {\n        if (this.stopped) return;\n        for (const chat of msg.chats) {\n          this.emit('chat', chat);\n        }\n        for (const gift of msg.gifts) {\n          this.emit('gift', gift);\n        }\n        for (const emotion of msg.emotions) {\n          this.emit('emotion', emotion);\n        }\n        for (const notification of msg.notifications) {\n          this.emit('notification', notification);\n        }\n        if (msg.operatorComment) {\n          this.emit('operatorComment', msg.operatorComment);\n        }\n      }\n    }\n\n    if (!this.stopped) {\n      this.emit('end');\n    }\n  }\n\n  stop(): void {\n    this.stopped = true;\n  }\n\n  private async fetchSegment(uri: string): Promise<Uint8Array> {\n    const controller = new AbortController();\n    const timer = setTimeout(() => controller.abort(), CONNECT_TIMEOUT_MS);\n\n    try {\n      const headers: Record<string, string> = {\n        'User-Agent':\n          'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',\n      };\n      if (this.cookies) headers['Cookie'] = this.cookies;\n\n      const response = await fetch(uri, {\n        headers,\n        signal: controller.signal,\n      });\n\n      clearTimeout(timer);\n\n      if (!response.ok) {\n        throw new Error(`Backward segment server returned ${response.status}`);\n      }\n\n      const buf = await response.arrayBuffer();\n      if (buf.byteLength > MAX_RESPONSE_SIZE) {\n        throw new Error(`Response size ${buf.byteLength} exceeds limit ${MAX_RESPONSE_SIZE}`);\n      }\n\n      return new Uint8Array(buf);\n    } catch (error) {\n      clearTimeout(timer);\n      throw error;\n    }\n  }\n}\n\nfunction delay(ms: number): Promise<void> {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}\n"],"mappings":"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","names":["EventEmitter","EventEmitter","EventEmitter","EventEmitter","MAX_BUFFER_SIZE","CONNECT_TIMEOUT_MS","INACTIVITY_TIMEOUT_MS","EventEmitter","EventEmitter","CONNECT_TIMEOUT_MS","EventEmitter","EventEmitter"]}